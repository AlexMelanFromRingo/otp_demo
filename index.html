<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>HOTP Demo — RFC 4226</title>
  <link rel="stylesheet" href="styles.css">
  <script type="module" src="js/app.js"></script>
</head>
<body>
  <!-- Header -->
  <header class="header">
    <h1 id="page-title">HOTP Демо — Одноразові паролі на основі лічильника (RFC 4226)</h1>
    <div class="header-controls">
      <div class="lang-group">
        <button id="lang-uk" class="lang-btn active">UA</button>
        <button id="lang-en" class="lang-btn">EN</button>
        <button id="lang-ru" class="lang-btn">RU</button>
      </div>
      <button id="theme-toggle" class="icon-btn" title="Toggle theme">🌙</button>
    </div>
  </header>

  <!-- Tabs -->
  <nav class="tabs">
    <button class="tab-btn active" data-tab="section-demo" id="tab-demo">Демо</button>
    <button class="tab-btn" data-tab="section-algorithm" id="tab-algorithm">Алгоритм HOTP</button>
    <button class="tab-btn" data-tab="section-data" id="tab-data">Структура даних</button>
    <button class="tab-btn" data-tab="section-about" id="tab-about">Про RFC 4226</button>
  </nav>

  <!-- Demo Section -->
  <main id="section-demo" class="tab-content active">

    <!-- Initial Setup -->
    <section class="setup-section" id="setup-section">
      <h2 id="setup-title">Налаштування системи</h2>
      <p class="step-desc" id="setup-desc">Спочатку потрібно налаштувати спільний секретний ключ між клієнтом та сервером. Це робиться один раз при реєстрації.</p>

      <div class="setup-controls">
        <button id="btn-generate" class="btn btn-primary">Згенерувати секретний ключ</button>
        <button id="btn-import" class="btn btn-secondary">Імпортувати ключ</button>
        <button id="btn-preset" class="btn btn-secondary">Завантажити приклад</button>
      </div>

      <div id="import-section" class="import-section hidden">
        <label id="import-label">Введіть секретний ключ (Hex або Base32):</label>
        <input type="text" id="import-input" class="input-field" placeholder="JBSWY3DPEHPK3PXP або 48656C6C6F21...">
        <div class="import-actions">
          <button id="btn-import-ok" class="btn btn-primary">Імпортувати</button>
          <button id="btn-import-cancel" class="btn btn-secondary">Скасувати</button>
        </div>
        <div id="import-error" class="error-message"></div>
      </div>
    </section>

    <!-- Main Demo (hidden until key generated) -->
    <div id="demo-content" class="hidden">

      <!-- Two-panel layout: Server & Client -->
      <div class="panels-container">

        <!-- SERVER PANEL -->
        <section class="panel server-panel">
          <div class="panel-header server-header">
            <h2 id="server-title">🖥️ Сервер</h2>
            <span class="panel-badge" id="server-badge">Аутентифікація</span>
          </div>

          <div class="panel-content">
            <!-- Server's view of shared secret -->
            <div class="data-block">
              <h3 id="server-secret-title">Секретний ключ (зберігається в БД)</h3>
              <div class="result-box">
                <span class="result-label">Hex</span>
                <code class="result-value" id="server-secret-hex"></code>
              </div>
              <div class="result-box">
                <span class="result-label">Base32</span>
                <code class="result-value" id="server-secret-base32"></code>
              </div>
            </div>

            <!-- Server's counter -->
            <div class="data-block">
              <h3 id="server-counter-title">Лічильник сервера</h3>
              <p class="step-desc" id="server-counter-desc">Сервер зберігає останній успішно використаний лічильник. Це запобігає повторному використанню того ж пароля.</p>
              <div class="counter-display">
                <span class="counter-value" id="server-counter">0</span>
                <span class="counter-label" id="server-counter-label">Поточний лічильник</span>
              </div>
            </div>

            <!-- Look-ahead window -->
            <div class="data-block">
              <h3 id="server-window-title">Вікно допуску (Look-ahead)</h3>
              <p class="step-desc" id="server-window-desc">Сервер перевіряє паролі для лічильників від поточного до поточного + вікно. Це дозволяє клієнту "випередити" сервер на кілька генерацій.</p>
              <div class="window-control">
                <label id="window-label">Розмір вікна:</label>
                <input type="number" id="window-size" class="input-small" value="5" min="1" max="20">
              </div>
              <div class="window-visual" id="window-visual">
                <!-- Generated by JS -->
              </div>
            </div>

            <!-- Verification input -->
            <div class="data-block">
              <h3 id="verify-title">Перевірка пароля</h3>
              <div class="verify-section">
                <input type="text" id="verify-input" class="input-field input-otp" placeholder="000000" maxlength="6">
                <button id="btn-verify" class="btn btn-primary">Перевірити</button>
              </div>
              <div id="verify-result" class="verify-result"></div>
              <div id="verify-details" class="verify-details hidden"></div>
            </div>

            <!-- Server logs -->
            <div class="data-block">
              <h3 id="server-log-title">Журнал подій</h3>
              <div class="log-container" id="server-log">
                <div class="log-empty" id="log-empty">Журнал порожній</div>
              </div>
              <button id="btn-clear-log" class="btn btn-secondary btn-small">Очистити журнал</button>
            </div>
          </div>
        </section>

        <!-- CLIENT PANEL -->
        <section class="panel client-panel">
          <div class="panel-header client-header">
            <h2 id="client-title">📱 Клієнт (Токен)</h2>
            <span class="panel-badge" id="client-badge">Генератор OTP</span>
          </div>

          <div class="panel-content">
            <!-- Client's view of shared secret -->
            <div class="data-block">
              <h3 id="client-secret-title">Секретний ключ (в пам'яті токена)</h3>
              <div class="result-box">
                <span class="result-label">Hex</span>
                <code class="result-value" id="client-secret-hex"></code>
              </div>
              <p class="step-desc secure-note" id="client-secret-note">⚠️ Цей ключ ніколи не передається по мережі після початкової реєстрації!</p>
            </div>

            <!-- Client's counter -->
            <div class="data-block">
              <h3 id="client-counter-title">Лічильник клієнта</h3>
              <p class="step-desc" id="client-counter-desc">Клієнт збільшує лічильник після кожної генерації пароля.</p>
              <div class="counter-display">
                <span class="counter-value" id="client-counter">0</span>
                <span class="counter-label" id="client-counter-label">Поточний лічильник</span>
              </div>
            </div>

            <!-- Generated OTP -->
            <div class="data-block otp-block">
              <h3 id="client-otp-title">Одноразовий пароль</h3>
              <div class="otp-display">
                <span class="otp-code" id="client-otp">------</span>
              </div>
              <button id="btn-generate-otp" class="btn btn-primary btn-large">Згенерувати пароль</button>
              <p class="step-desc" id="client-otp-note">Натисніть кнопку, щоб згенерувати новий OTP. Лічильник збільшиться на 1.</p>
            </div>

            <!-- Detailed algorithm steps (expandable) -->
            <div class="data-block">
              <button class="expand-btn" id="btn-expand-steps">
                <span id="expand-text">Показати кроки алгоритму</span>
                <span class="expand-icon">▼</span>
              </button>

              <div id="algorithm-steps" class="algorithm-steps hidden">
                <!-- Step 1: Counter as bytes -->
                <div class="step-card mini">
                  <h4 id="step1-title">Крок 1: Лічильник → Байти</h4>
                  <p class="step-desc" id="step1-desc">Лічильник перетворюється в 8 байт (big-endian).</p>
                  <div class="result-box">
                    <span class="result-label" id="step1-label">Лічильник (hex, 8 байт)</span>
                    <code class="result-value" id="step1-value">0000000000000000</code>
                  </div>
                </div>

                <!-- Step 2: HMAC-SHA1 -->
                <div class="step-card mini">
                  <h4 id="step2-title">Крок 2: HMAC-SHA1</h4>
                  <p class="step-desc" id="step2-desc">Обчислюємо HMAC-SHA1(secret, counter_bytes).</p>
                  <div class="formula" id="step2-formula">HMAC = HMAC-SHA1(K, C)</div>
                  <div class="result-box">
                    <span class="result-label" id="step2-label">HMAC результат (20 байт)</span>
                    <code class="result-value" id="step2-value">--------------------</code>
                  </div>
                </div>

                <!-- Step 3: Dynamic Truncation -->
                <div class="step-card mini">
                  <h4 id="step3-title">Крок 3: Динамічне обрізання</h4>
                  <p class="step-desc" id="step3-desc">Витягуємо 4 байти з позиції offset = hmac[19] & 0x0F.</p>

                  <div class="substep">
                    <span class="substep-label" id="step3-offset-label">Offset:</span>
                    <code id="step3-offset">0</code>
                  </div>

                  <div class="byte-diagram" id="byte-diagram">
                    <!-- Generated by JS -->
                  </div>

                  <div class="result-grid">
                    <div class="result-box">
                      <span class="result-label" id="step3-extracted-label">Витягнуті байти</span>
                      <code class="result-value" id="step3-extracted">00000000</code>
                    </div>
                    <div class="result-box">
                      <span class="result-label" id="step3-int-label">31-бітне число</span>
                      <code class="result-value" id="step3-int">0</code>
                    </div>
                  </div>
                </div>

                <!-- Step 4: Modulo -->
                <div class="step-card mini">
                  <h4 id="step4-title">Крок 4: Модуло 10⁶</h4>
                  <p class="step-desc" id="step4-desc">Залишок від ділення на 1,000,000 дає 6-значний код.</p>
                  <div class="formula" id="step4-formula">HOTP = Sbits mod 10⁶</div>
                  <div class="result-box">
                    <span class="result-label" id="step4-calc-label">Обчислення</span>
                    <code class="result-value" id="step4-calc">0 mod 1000000 = 0</code>
                  </div>
                  <div class="result-box result-final">
                    <span class="result-label">HOTP</span>
                    <code class="result-value result-code" id="step4-result">000000</code>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </section>

      </div><!-- /panels-container -->

      <!-- Synchronization demo -->
      <section class="sync-section">
        <h2 id="sync-title">Демонстрація синхронізації</h2>
        <p class="step-desc" id="sync-desc">Ця секція показує, що відбувається, коли лічильники клієнта та сервера розходяться.</p>

        <div class="sync-controls">
          <button id="btn-desync" class="btn btn-warning">Розсинхронізувати (+3 на клієнті)</button>
          <button id="btn-resync" class="btn btn-secondary">Ресинхронізувати</button>
        </div>

        <div class="sync-visual">
          <div class="sync-bar">
            <div class="sync-label" id="sync-server-label">Сервер</div>
            <div class="sync-counter" id="sync-server">0</div>
          </div>
          <div class="sync-bar">
            <div class="sync-label" id="sync-client-label">Клієнт</div>
            <div class="sync-counter" id="sync-client">0</div>
          </div>
          <div class="sync-window" id="sync-window">
            <!-- Look-ahead window visualization -->
          </div>
        </div>
      </section>

    </div><!-- /demo-content -->
  </main>

  <!-- Algorithm Section -->
  <section id="section-algorithm" class="tab-content">
    <article class="about-content">
      <h2 id="algo-title">Алгоритм HOTP — RFC 4226</h2>

      <h3 id="algo-overview-title">Загальний огляд</h3>
      <p class="about-text" id="algo-overview-text">
HOTP (HMAC-based One-Time Password) — це алгоритм генерації одноразових паролів,
описаний в RFC 4226 (грудень 2005). Він використовує HMAC-SHA1 для генерації
унікальних паролів на основі спільного секретного ключа та лічильника.
      </p>

      <h3 id="algo-formula-title">Математична формула</h3>
      <pre class="about-pre" id="algo-formula-text">
HOTP(K, C) = Truncate(HMAC-SHA1(K, C)) mod 10^Digit

Де:
  K = Секретний ключ (мінімум 128 біт, рекомендовано 160 біт)
  C = 8-байтний лічильник (big-endian)
  Digit = Кількість цифр в OTP (зазвичай 6)
  Truncate = Функція динамічного обрізання (DT)
      </pre>

      <h3 id="algo-dt-title">Динамічне обрізання (Dynamic Truncation)</h3>
      <p class="about-text" id="algo-dt-text">
Функція DT витягує 4 байти з 20-байтного HMAC результату:
      </p>
      <pre class="about-pre" id="algo-dt-code">
1. offset = hmac[19] & 0x0F          // Останній півбайт визначає зміщення
2. binary = hmac[offset..offset+4]   // Витягуємо 4 байти
3. binary[0] &= 0x7F                 // Обнуляємо старший біт (знаковий)
4. Sbits = binary as u32             // Інтерпретуємо як 32-бітне число
5. OTP = Sbits mod 10^Digit          // Залишок від ділення
      </pre>

      <h3 id="algo-why-title">Навіщо таке обрізання?</h3>
      <p class="about-text" id="algo-why-text">
• <strong>Чому offset з останнього байту?</strong> — Це додає непередбачуваності.
  Зловмисник не може знати заздалегідь, які саме байти будуть використані.

• <strong>Чому обнуляється старший біт?</strong> — Щоб уникнути проблем зі знаковими
  числами в різних мовах програмування. Число завжди буде додатним.

• <strong>Чому mod 10^6?</strong> — Щоб отримати рівно 6 цифр. Це зручно для введення
  користувачем і забезпечує 1 мільйон можливих комбінацій.
      </p>

      <h3 id="algo-security-title">Параметри безпеки</h3>
      <pre class="about-pre" id="algo-security-text">
┌─────────────────────────────────────────────────────────────┐
│ Параметр                    │ Рекомендоване значення       │
├─────────────────────────────┼──────────────────────────────┤
│ Довжина секретного ключа    │ 160 біт (20 байт)            │
│ Кількість цифр (Digit)      │ 6 цифр                       │
│ Вікно допуску (look-ahead)  │ 3-10 спроб                   │
│ Блокування після помилок    │ 3-5 невдалих спроб           │
│ Час життя ключа             │ 1-2 роки                     │
└─────────────────────────────┴──────────────────────────────┘
      </pre>
    </article>
  </section>

  <!-- Data Structure Section -->
  <section id="section-data" class="tab-content">
    <article class="about-content">
      <h2 id="data-title">Структура даних HOTP системи</h2>

      <h3 id="data-overview-title">Огляд архітектури</h3>
      <pre class="about-pre" id="data-overview-text">
┌─────────────────────────────────────────────────────────────────────┐
│                        HOTP СИСТЕМА                                 │
├─────────────────────────────┬───────────────────────────────────────┤
│         КЛІЄНТ              │              СЕРВЕР                   │
│      (Токен/Додаток)        │         (Аутентифікація)              │
├─────────────────────────────┼───────────────────────────────────────┤
│                             │                                       │
│  ┌─────────────────────┐    │    ┌─────────────────────────────┐   │
│  │ Секретний ключ K    │◄───┼────┤ Секретний ключ K (в БД)     │   │
│  │ (захищена пам'ять)  │    │    │ (шифрований)                │   │
│  └─────────────────────┘    │    └─────────────────────────────┘   │
│           │                 │                │                      │
│           ▼                 │                ▼                      │
│  ┌─────────────────────┐    │    ┌─────────────────────────────┐   │
│  │ Лічильник C         │    │    │ Лічильник C (в БД)          │   │
│  │ (зберігається)      │    │    │ (останній успішний)         │   │
│  └─────────────────────┘    │    └─────────────────────────────┘   │
│           │                 │                │                      │
│           ▼                 │                ▼                      │
│  ┌─────────────────────┐    │    ┌─────────────────────────────┐   │
│  │ HOTP(K, C) → OTP    │────┼───►│ Перевірка OTP               │   │
│  │ C = C + 1           │    │    │ для C, C+1, ..., C+window   │   │
│  └─────────────────────┘    │    └─────────────────────────────┘   │
│                             │                                       │
└─────────────────────────────┴───────────────────────────────────────┘
      </pre>

      <h3 id="data-client-title">Дані на клієнті (токен)</h3>
      <pre class="about-pre" id="data-client-text">
┌─────────────────────────────────────────────────────────────┐
│ ТОКЕН / МОБІЛЬНИЙ ДОДАТОК                                   │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│ Захищена пам'ять (Secure Element / Keychain):               │
│ ┌─────────────────────────────────────────────────────────┐ │
│ │ secret_key: [u8; 20]                                    │ │
│ │   Приклад: 0x48 0x65 0x6C 0x6C 0x6F 0x21 0xDE 0xAD ...  │ │
│ │   Або Base32: JBSWY3DPEHPK3PXP                          │ │
│ └─────────────────────────────────────────────────────────┘ │
│                                                             │
│ Звичайна пам'ять:                                           │
│ ┌─────────────────────────────────────────────────────────┐ │
│ │ counter: u64 = 0                                        │ │
│ │   Збільшується на 1 після кожної генерації              │ │
│ │   Зберігається між перезавантаженнями                   │ │
│ └─────────────────────────────────────────────────────────┘ │
│                                                             │
│ Тимчасові дані (не зберігаються):                           │
│ ┌─────────────────────────────────────────────────────────┐ │
│ │ current_otp: String = "------"                          │ │
│ │   Згенерований OTP для відображення користувачу         │ │
│ └─────────────────────────────────────────────────────────┘ │
│                                                             │
└─────────────────────────────────────────────────────────────┘
      </pre>

      <h3 id="data-server-title">Дані на сервері</h3>
      <pre class="about-pre" id="data-server-text">
┌─────────────────────────────────────────────────────────────┐
│ СЕРВЕР АУТЕНТИФІКАЦІЇ                                       │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│ База даних користувачів (таблиця otp_secrets):              │
│ ┌─────────────────────────────────────────────────────────┐ │
│ │ CREATE TABLE otp_secrets (                              │ │
│ │   user_id        INTEGER PRIMARY KEY,                   │ │
│ │   username       VARCHAR(255) NOT NULL,                 │ │
│ │   secret_key     BLOB NOT NULL,  -- 20 байт, шифровано  │ │
│ │   counter        BIGINT DEFAULT 0,                      │ │
│ │   failed_attempts INTEGER DEFAULT 0,                    │ │
│ │   locked_until   TIMESTAMP NULL,                        │ │
│ │   created_at     TIMESTAMP DEFAULT CURRENT_TIMESTAMP,   │ │
│ │   last_used_at   TIMESTAMP NULL                         │ │
│ │ );                                                      │ │
│ └─────────────────────────────────────────────────────────┘ │
│                                                             │
│ Конфігурація сервера:                                       │
│ ┌─────────────────────────────────────────────────────────┐ │
│ │ look_ahead_window: u32 = 5                              │ │
│ │   Максимальне випередження клієнта                      │ │
│ │                                                         │ │
│ │ max_failed_attempts: u32 = 3                            │ │
│ │   Блокування після N невдалих спроб                     │ │
│ │                                                         │ │
│ │ lockout_duration: Duration = 30 minutes                 │ │
│ │   Тривалість блокування                                 │ │
│ └─────────────────────────────────────────────────────────┘ │
│                                                             │
│ Журнал аудиту (таблиця otp_audit_log):                      │
│ ┌─────────────────────────────────────────────────────────┐ │
│ │ CREATE TABLE otp_audit_log (                            │ │
│ │   id          INTEGER PRIMARY KEY,                      │ │
│ │   user_id     INTEGER NOT NULL,                         │ │
│ │   event_type  VARCHAR(50),  -- 'success', 'failure'     │ │
│ │   counter_used BIGINT,                                  │ │
│ │   ip_address  VARCHAR(45),                              │ │
│ │   user_agent  TEXT,                                     │ │
│ │   timestamp   TIMESTAMP DEFAULT CURRENT_TIMESTAMP       │ │
│ │ );                                                      │ │
│ └─────────────────────────────────────────────────────────┘ │
│                                                             │
└─────────────────────────────────────────────────────────────┘
      </pre>

      <h3 id="data-flow-title">Потік даних при аутентифікації</h3>
      <pre class="about-pre" id="data-flow-text">
Крок 1: Генерація OTP на клієнті
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   Клієнт
   ┌───────────────────┐
   │ K = secret_key    │
   │ C = counter = 3   │
   │                   │
   │ OTP = HOTP(K, C)  │──────────────────►  Користувач бачить: 482937
   │     = 482937      │
   │                   │
   │ counter = 4       │  ◄── Лічильник збільшено!
   └───────────────────┘

Крок 2: Передача OTP (небезпечний канал - OK!)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   Клієнт ────────────────────────────────► Сервер
            username: "alice"
            otp: "482937"

   ⚠️ Зловмисник може перехопити, АЛЕ:
      - OTP дійсний лише один раз
      - Потрібно встигнути до легітимного користувача

Крок 3: Верифікація на сервері
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   Сервер
   ┌───────────────────────────────────────────────┐
   │ user = find_user("alice")                     │
   │ K = decrypt(user.secret_key)                  │
   │ C = user.counter = 2                          │
   │ window = 5                                    │
   │                                               │
   │ for i in 0..window:                           │
   │   expected = HOTP(K, C + i)                   │
   │   if expected == received_otp:                │
   │     user.counter = C + i + 1  ◄── Оновлення!  │
   │     return SUCCESS                            │
   │                                               │
   │ C=2: HOTP = 847291 ≠ 482937                   │
   │ C=3: HOTP = 482937 = 482937 ✓                 │
   │                                               │
   │ user.counter = 4  ◄── Тепер сервер синхронізований
   └───────────────────────────────────────────────┘
      </pre>

      <h3 id="data-sync-title">Проблема десинхронізації</h3>
      <pre class="about-pre" id="data-sync-text">
Сценарій: Клієнт згенерував паролі, але не відправив їх
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Початковий стан:
  Клієнт: counter = 5
  Сервер: counter = 5

Користувач випадково натиснув кнопку 3 рази:
  Клієнт: counter = 8  (згенерував OTP для 5, 6, 7)
  Сервер: counter = 5  (нічого не отримав)

Тепер користувач хоче увійти:
  Клієнт генерує OTP для counter = 8
  Сервер перевіряє: 5, 6, 7, 8, 9 (window = 5)

  ✓ OTP для counter = 8 знайдено у вікні!
  Сервер оновлює: counter = 9

Якби window був менший (наприклад, 2):
  Сервер перевіряє: 5, 6
  ✗ OTP для counter = 8 не знайдено!
  Користувач заблокований!

Рішення: Ресинхронізація
━━━━━━━━━━━━━━━━━━━━━━━━━
  1. Користувач вводить 2-3 послідовних OTP
  2. Сервер шукає ці OTP в великому вікні (100-1000)
  3. Якщо знайдено послідовність — синхронізація відновлена
      </pre>
    </article>
  </section>

  <!-- About Section -->
  <section id="section-about" class="tab-content">
    <article class="about-content">
      <h2 id="about-title">Про HOTP — RFC 4226</h2>

      <h3 id="about-history-title">Історія та розробка</h3>
      <p class="about-text" id="about-history-text">
RFC 4226 "HOTP: An HMAC-Based One-Time Password Algorithm" був опублікований
у грудні 2005 року. Автори: D. M'Raihi (Verisign), M. Bellare (UCSD),
F. Hoornaert (Vasco), D. Naccache (ENS), O. Ranen (Aladdin).

Стандарт був розроблений OATH (Initiative for Open Authentication) —
промисловим консорціумом, що об'єднує такі компанії як Verisign,
RSA Security, Symantec та інші.
      </p>

      <h3 id="about-vs-totp-title">HOTP vs TOTP</h3>
      <pre class="about-pre" id="about-vs-totp-text">
┌──────────────────────┬──────────────────────┬──────────────────────┐
│ Характеристика       │ HOTP (RFC 4226)      │ TOTP (RFC 6238)      │
├──────────────────────┼──────────────────────┼──────────────────────┤
│ Рік публікації       │ 2005                 │ 2011                 │
│ Основа лічильника    │ Інкрементний         │ Часовий              │
│ Синхронізація        │ Потрібне вікно       │ Автоматична (час)    │
│ Термін дії OTP       │ До використання      │ 30 секунд            │
│ Фізичний токен       │ Ідеальний            │ Потрібен годинник    │
│ Мобільний додаток    │ Можливий             │ Ідеальний            │
│ Приклад              │ RSA SecurID (старі)  │ Google Authenticator │
└──────────────────────┴──────────────────────┴──────────────────────┘
      </pre>

      <h3 id="about-usage-title">Використання в реальному світі</h3>
      <p class="about-text" id="about-usage-text">
HOTP широко використовується в:
• Апаратних токенах (RSA SecurID, YubiKey)
• Банківських системах
• VPN аутентифікації
• Корпоративних системах доступу

TOTP (на основі HOTP) більш популярний для мобільних додатків через
автоматичну синхронізацію часу. Google Authenticator, Microsoft
Authenticator, Authy — всі використовують TOTP.
      </p>

      <h3 id="about-security-title">Аналіз безпеки</h3>
      <p class="about-text" id="about-security-text">
<strong>Сильні сторони:</strong>
• Базується на HMAC-SHA1 — криптографічно стійкий
• Захист від replay-атак (лічильник)
• Секретний ключ ніколи не передається

<strong>Слабкі сторони:</strong>
• Потенційна десинхронізація лічильників
• Потрібно безпечно зберігати секретний ключ на обох сторонах
• SHA-1 теоретично має колізії (але для HMAC це не критично)

<strong>Рекомендації RFC 4226:</strong>
• Мінімальна довжина ключа: 128 біт
• Рекомендована довжина ключа: 160 біт (20 байт)
• Throttling після невдалих спроб
• Secure storage для секретного ключа
      </p>

      <h3 id="about-links-title">Посилання</h3>
      <p class="about-text" id="about-links-text">
• <a href="https://datatracker.ietf.org/doc/html/rfc4226" target="_blank">RFC 4226 — HOTP Algorithm</a>
• <a href="https://datatracker.ietf.org/doc/html/rfc6238" target="_blank">RFC 6238 — TOTP Algorithm</a>
• <a href="https://openauthentication.org/" target="_blank">OATH — Open Authentication</a>
      </p>
    </article>
  </section>

</body>
</html>
